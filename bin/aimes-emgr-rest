#!/usr/bin/env python

import os
import time
import bottle 
import threading

import radical.utils as ru


# ------------------------------------------------------------------------------
#
# read configuration
#
config        = ru.read_json('config.json')
swift_root    = "%s/swift" % config["path"]
swift_timeout = 10      # run workload after 10 seconds of idleness
swift_runlog  = dict()  # record running units

# make sure the root exists
os.system('mkdir -p %s' % swift_root)


# We define two different APIs:
#
# The first, 'AIMES-API' allows to define and run experiments, similar to the
# functionality used in examples/aimes-emgr-experiments.  It basically reflects:
#
#     run = aimes.emgr.create_run_environment(cfg, run_cfg, tracker, queue.qsize())
#     aimes.emgr.execute_run(cfg, run)
#     aimes.emgr.finalize_run_environment(cfg, run)
#
# The second we call 'SWIFT-API': it supports the definition of a workload by
# defining a stream of CUs, and to at some point run that:
#
#     workload = aimes.emgr.create_swift_workload()
#
#     for i in range(100):
#         workload.add (cu_description)
#
#     workload.run()
#
#     for i in range(100):
#         workload.get_state (i)
#

# ==============================================================================
#
# AIMES API
#
# ==============================================================================

# ==============================================================================
#
# SWIFT API
#
# ==============================================================================

# ------------------------------------------------------------------------------
# keep a global counter for unit IDs
uids = dict()


# ------------------------------------------------------------------------------
#
# update timestamps for workloads.  See documentation of _workload_watcher() to
# see why
#
# We lock timestamp activities.  That single lock won't scale far...
ts_lock = threading.RLock()
def _timestamp(swid):

    with ts_lock:
        now = time.time()
        os.system ('echo "%s" > %s/%s/timestamp' % (now, swift_root, swid))


# ------------------------------------------------------------------------------
#
def _get_timestamp(swid):

    with ts_lock:
        try:
            with open ("%s/%s/timestamp" % (swift_root, swid), "r") as f:
                return float(f.read().strip())
        except Exception as e:
            print "could not read timstamp for %s: %s" % (swid, e)
            return None


# ------------------------------------------------------------------------------
#
# run a (partial) workload
#
def _run_workload(swid):

    try:
        workload_dir = '%s/%s/' % (swift_root, swid)
        if not os.path.exists (workload_dir):
            raise ValueError ("workload id %s does not exist" % swid)

        # avoid rerunning units on the next timeout, by recording a runlog
        if not swid in swift_runlog:
            swift_runlog[swid] = list()

        runlog = swift_runlog[swid]

        # collect all units which are not in the runlog
        sw = dict()
        sw['cuds'] = list()

        paths = os.listdir(workload_dir)
        for f in paths:
            if f.startswith('cu.'):
                if f in runlog:
                    print 'skipping %s' % f
                else:
                    sw['cuds'].append(ru.read_json("%s/%s" % (workload_dir,f)))
                    runlog.append(f)

        # FIXME: we need config files and a 'run' struct here, so that emgr can
        #        actually start managing things.
        import aimes.emgr
        cfg = 1
        run = 2
        ret = aimes.emgr.execute_swift_workload (cfg, run, sw)

        print "execution done: %s" % ret

        # remove the timestamp -- no need to watch this workload until new units
        # arrive
        try:
            os.unlink("%s/timestamp" % workload_dir)
        except:
            pass

        return ret

    except Exception as e:
        print "ERROR: workload execution failed: %s" % e
        raise


# ------------------------------------------------------------------------------
# list all swift workload
@bottle.route('/swift/workloads/', method='GET')
def swift_workload_list():

    paths = os.listdir(swift_root)

    return {"success" : True  , 
            "paths"   : paths }
    

# ------------------------------------------------------------------------------
# create a new swift workload
@bottle.route('/swift/workloads/', method='PUT')
def swift_workload_create():

    swid = ru.generate_id (prefix="sw.%(days)06d.%(day_counter)04d",
                           mode=ru.ID_CUSTOM)

    if os.path.exists ('%s/%s/' % (swift_root, swid)):
        return {"success" : False, 
                "swid"    : swid,
                "error"   : "workload id '%s' exists" % swid}
    
    os.system ('mkdir %s/%s/' % (swift_root, swid))

    uids[swid] = 0
    
    return {"success" : True, 
            "swid"    : swid,
            "result"  : "workload '%s' has been created" % swid}
    

# ------------------------------------------------------------------------------
# add a CU to a swift workload
@bottle.route('/swift/workloads/<swid>', method='PUT')
def swift_workload_add_cu(swid=None):

    if not swid:
        return {"success" : False, 
                "swid"    : swid,
                "error"   : "missing workload id"}
    
    # look for in swift_root/<swid>/
    workload_dir = '%s/%s/' % (swift_root, swid)
    if not os.path.exists (workload_dir):
        return {"success" : False, 
                "swid"    : swid,
                "error"   : "workload id %s does not exist" % swid}

    cud = bottle.request.forms.get("cud")

    if not cud:
        return {"success" : False, 
                "swid"    : swid,
                "error"   : "missing cu description"}

    import pprint
    pprint.pprint (cud)

    cuid  = uids[swid]
    fname = '%s/%s/cu.%04d.json' % (swift_root, swid, cuid)
    ru.write_json(cud, fname)

    _timestamp(swid)
    uids[swid] += 1
    
    return {"success" : True, 
            "swid"    : swid,
            "cuid"    : cuid,
            "result"  : "unit '%s' created for workload %s" % (cuid, swid)}
    

# ------------------------------------------------------------------------------
# list currently defined units in the workload
@bottle.route('/swift/workloads/<swid>', method='GET')
def swift_workload_show(swid=None):

    if not swid:
        return {"success" : False, 
                "swid"    : swid,
                "error"   : "missing workload id"}
    
    workload_dir = '%s/%s/' % (swift_root, swid)
    if not os.path.exists (workload_dir):
        return {"success" : False, 
                "swid"    : swid,
                "error"   : "workload id %s does not exist" % swid}

    ret = dict()
    ret['cuds'] = list()
    try:
        paths = os.listdir(workload_dir)
        for f in paths:
            if f.startswith('cu.'):
                ret['cuds'].append(ru.read_json("%s/%s" % (workload_dir,f)))

    except Exception as e:
        return {"success" : False, 
                "swid"    : swid,
                "error"   : "Exception: %s" % e}

    bottle.response.content_type = 'application/json'
    return {"success" : True, 
            "swid"    : swid,
            "result"  : ret}
    

# ------------------------------------------------------------------------------
#
# delete a specific workload
#
@bottle.route('/swift/workloads/<swid>', method='DELETE' )
def swift_workload_delete(swid=None):

    if not swid:
        return {"success" : False, 
                "swid"    : None,
                "error"   : "missing workload id"}
    
    # remove workloads from tree
    os.system ('rm    %s/%s/*' % (swift_root, swid))
    os.system ('rmdir %s/%s/'  % (swift_root, swid))

    uids[swid] = 0
    del(swift_runlog[swid])

    return {"success" : True, 
            "swid"    : swid,
            "result"  : "workload %s deleted" % swid}
            
    
# ------------------------------------------------------------------------------
#
# run a specific workload
#
@bottle.route('/swift/workloads/<swid>/execute', method='PUT')
def swift_workload_run(swid=None):

    if not swid:
        return {"success" : False, 
                "swid"    : swid,
                "error"   : "missing workload id"}
    
    ret = None
    try:
        print "explicit workload run for %s" % swid
        ret = _run_workload(swid)

    except Exception as e:
        return {"success" : False, 
                "swid"    : swid,
                "error"   : "Exception: %s" % e}

    bottle.response.content_type = 'application/json'
    return {"success" : True, 
            "swid"    : swid,
            "result"  : ret}
    
# ------------------------------------------------------------------------------
#
# Swift will never know if more tasks get submitted, so it cannot sensibly call
# 'swift_workload_run'.  We thus run a separate thread which watches all
# workloads, and if a workload did not see any new units added for N seconds, it
# will call run on it.
#
# FIXME: any error on workload execution will not be visible to the user of the
#        service.  We should log errors to a file and add a 'workload_status'
#        method.
#
def _workload_watcher(terminate):

    print "timed workload watcher started"

    workloads = dict()

    while not terminate.is_set():


        paths = os.listdir(swift_root)

        for swid in paths:

          # print "timed workload check for %s" % swid

            ts_file = "%s/%s/timestamp" % (swift_root, swid)

            if not os.path.exists (ts_file):
                # workload does not need any watching
                continue

            # no timestamp -- nothing to do
            last_action = _get_timestamp(swid)
            if not last_action:
              # print "timed workload check for %s misses timestamp" % swid
                continue

            # otherwise we check if enough time passed -- if not, nothing to do
            if (time.time() - last_action) < swift_timeout:
                print "timed workload check for %s skipped (%.2f < %.2f)" \
                        % (swid, (time.time() - last_action), swift_timeout)
                continue

            # we should run this workload
            try:
                print "timed workload run for %s" % swid
                _run_workload(swid)
            except Exception as e:
                print "error on timed workload run for %s: %s" % (swid, e)

        # avoid busy loop
        time.sleep(1)

# ------------------------------------------------------------------------------
#
#
terminate = threading.Event()
watcher   = threading.Thread (target=_workload_watcher, args=[terminate])
watcher.start()
bottle.run (host='localhost', port=8080, debug=True)

terminate.set()
watcher.join()


# ------------------------------------------------------------------------------

